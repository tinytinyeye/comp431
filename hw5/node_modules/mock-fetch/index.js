
const getMethod = (options) => (options && options.method) ? options.method : 'GET'

const fetch = (url, options) => {
    return new Promise((resolve, reject) => {
        const method = getMethod(options)
        if (!_mocks[method] || !_mocks[method][url] || _mocks[method][url].length == 0)
            reject(new Error('No mock available for ' + url + ':' + options))
        resolve(_mocks[method][url].shift())
    })
}

fetch.isMock = () => true

const _mocks = {}

const mock = (url, options) => {
    const method = getMethod(options)
    if (!_mocks[method]) {
        _mocks[method] = {}
    }
    if (!_mocks[method][url]) {
        _mocks[method][url] = []
    }
    const response = {}
    Object.keys(options).forEach(key => {
        response[key] = options[key]
    })
    if (!response.status) {
        response.status = 200
    }
    response.headers.get = (key) => options.headers[key]
    response.json = () => new Promise((resolve, reject) => resolve(options.json))
    response.text = () => new Promise((resolve, reject) => resolve(options.text))
    _mocks[method][url].push(response)
}

module.exports = fetch
module.exports.mock = mock

